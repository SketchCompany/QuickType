{"version":3,"sources":["../src/index.ts","../src/lexer.ts","../src/parser.ts","../src/values.ts","../src/natives.ts","../src/environment.ts","../src/expressions.ts","../src/statements.ts","../src/interpreter.ts","../src/main.ts"],"sourcesContent":["import {runLanguage} from \"./main\"\r\n\r\n/**\r\n * This method runs the complete programming language, to read your `input` / `code`, parse it and interpret it, so you can get an `output` / `result` about your `program`.\r\n * @param {string} input is the `path` to the file, where your `input` / `code` is existing in\r\n */\r\nexport function run(input:string){\r\n    runLanguage(input)\r\n}","function checkLetter(c: string){\r\n    return /[a-zA-Z]$/.test(c)\r\n}\r\nfunction checkNumber(c: string){\r\n    return /[0-9]$/.test(c)\r\n}\r\n\r\nexport enum TokenType{\r\n    Number,\r\n    Identifier,\r\n    String,\r\n    Comment,\r\n\r\n    OpenParen, \r\n    CloseParen,\r\n    OpenBrace,\r\n    CloseBrace,\r\n    OpenBracket,\r\n    CloseBracket,\r\n\r\n    BinaryOperator,\r\n    Equals,\r\n    Semicolon,\r\n    Comma,\r\n    Colon,\r\n    Dot,\r\n    ExclamationMark,\r\n    \r\n    VerticalBarOperator,\r\n    AmpersandOperator,\r\n\r\n    EqualsComperator,\r\n    NotEqualsComperator,\r\n    GreaterComperator,\r\n    LessComperator,\r\n    NotGreaterComperator,\r\n    NotLessComperator,\r\n\r\n    Let,\r\n    Const,\r\n    Fn,\r\n    If,\r\n    Else,\r\n    For,\r\n    While,\r\n    Return,\r\n\r\n    EOF,\r\n}\r\n\r\nexport interface Token{\r\n    value: string,\r\n    type: TokenType\r\n}\r\n\r\nconst KEYWORDS: Record<string, TokenType> = {\r\n    \"v\": TokenType.Let,\r\n    \"c\": TokenType.Const,\r\n    \"f\": TokenType.Fn,\r\n    \"if\": TokenType.If,\r\n    \"else\": TokenType.Else,\r\n    \"and\": TokenType.AmpersandOperator,\r\n    \"or\": TokenType.VerticalBarOperator,\r\n    \"not\": TokenType.NotEqualsComperator,\r\n    \"is\": TokenType.EqualsComperator,\r\n    \"gt\": TokenType.GreaterComperator,\r\n    \"ls\": TokenType.LessComperator,\r\n    \"ngt\": TokenType.NotGreaterComperator,\r\n    \"nls\": TokenType.NotLessComperator,\r\n    \"for\": TokenType.For,\r\n    \"while\": TokenType.While,\r\n}\r\n\r\nfunction addToken(value = \"\", type: TokenType){\r\n    return {value, type}\r\n}\r\n\r\n/**\r\n * tokenizes a given `string` into the `token type` and its `value`\r\n * @param {string} code is the `string` that needs to be tokenized\r\n * @returns {Array<JSON>} an `Array` with the found tokens in JSON format, for example like this: \r\n * ```\r\n * {token: \"IDENTIFIER\", value: \"example\"}\r\n * ```\r\n */\r\nexport function tokenize(code: string): Token[]{\r\n    const tokens = new Array<Token>()\r\n    const src = code.split(\"\")\r\n\r\n    while(src.length > 0){\r\n        if(src[0] === \"(\"){\r\n            tokens.push(addToken(src.shift(), TokenType.OpenParen))\r\n        }\r\n        else if(src[0] === \")\"){\r\n            tokens.push(addToken(src.shift(), TokenType.CloseParen))\r\n        }\r\n        else if(src[0] === \"{\"){\r\n            tokens.push(addToken(src.shift(), TokenType.OpenBrace))\r\n        }\r\n        else if(src[0] === \"}\"){\r\n            tokens.push(addToken(src.shift(), TokenType.CloseBrace))\r\n        }\r\n        else if(src[0] === \"[\"){\r\n            tokens.push(addToken(src.shift(), TokenType.OpenBracket))\r\n        }\r\n        else if(src[0] === \"]\"){\r\n            tokens.push(addToken(src.shift(), TokenType.CloseBracket))\r\n        }\r\n        else if(src[0] === \"/\" && src[1] === \"*\"){\r\n            src.shift()\r\n            src.shift()\r\n            while(src.length > 0){\r\n                if(src.shift() != \"*\" || src.shift() != \"/\") continue\r\n                else break\r\n            }\r\n        }\r\n        else if(src[0] === \"/\" && src[1] === \"/\"){\r\n            src.shift()\r\n            src.shift()\r\n            while(src.length > 0 && src.shift() != \"\\n\"){\r\n                continue\r\n            }\r\n        }\r\n        else if(src[0] === \"+\" || src[0] === \"-\" || src[0] === \"*\" || src[0] === \"/\" || src[0] === \"%\"){\r\n            tokens.push(addToken(src.shift(), TokenType.BinaryOperator))\r\n        }\r\n        else if(src[0] === \"=\" && src[1] !== \"=\"){\r\n            tokens.push(addToken(src.shift(), TokenType.Equals))\r\n        }\r\n        // else if(src[0] === \";\"){\r\n        //     tokens.push(addToken(src.shift(), TokenType.Semicolon))\r\n        // }\r\n        else if(src[0] === \":\"){\r\n            tokens.push(addToken(src.shift(), TokenType.Colon))\r\n        }\r\n        else if(src[0] === \",\"){\r\n            tokens.push(addToken(src.shift(), TokenType.Comma))\r\n        }\r\n        else if(src[0] === \".\"){\r\n            tokens.push(addToken(src.shift(), TokenType.Dot))\r\n        }\r\n        else if(src[0] === \">\"){\r\n            tokens.push(addToken(src.shift(), TokenType.GreaterComperator))\r\n        }\r\n        else if(src[0] === \"<\"){\r\n            tokens.push(addToken(src.shift(), TokenType.LessComperator))\r\n        }\r\n        else if(src[0] === \"|\"){\r\n            src.shift()\r\n            tokens.push(addToken(\"|\", TokenType.VerticalBarOperator))\r\n        }\r\n        else if(src[0] === \"&\"){\r\n            src.shift()\r\n            tokens.push(addToken(\"&\", TokenType.AmpersandOperator))\r\n        }\r\n        else if(src[0] === \"=\"){\r\n            if(src[1] === \"=\"){\r\n                src.shift()\r\n                src.shift()\r\n                tokens.push(addToken(\"==\", TokenType.EqualsComperator))\r\n            }\r\n        }\r\n        else if(src[0] === \"!\"){\r\n            if(src[1] === \"=\"){\r\n                src.shift()\r\n                src.shift()\r\n                tokens.push(addToken(\"!=\", TokenType.NotEqualsComperator))\r\n            }\r\n            else if(src[1] === \"<\"){\r\n                src.shift()\r\n                src.shift()\r\n                tokens.push(addToken(\"!<\", TokenType.NotLessComperator))\r\n            }\r\n            else if(src[1] === \">\"){\r\n                src.shift()\r\n                src.shift()\r\n                tokens.push(addToken(\"!>\", TokenType.NotGreaterComperator))\r\n            }\r\n            else{\r\n                src.shift()\r\n                tokens.push(addToken(\"!\", TokenType.ExclamationMark))\r\n            }\r\n        }\r\n        else{\r\n            if(src[0] === \"\\\"\"){\r\n                src.shift()\r\n                let string = \"\"\r\n                while(src.length > 0 && src[0] != \"\\\"\"){\r\n                    string += src.shift()\r\n                }\r\n                src.shift()\r\n                tokens.push(addToken(string, TokenType.String))\r\n            }\r\n            else if(src[0] === \"'\"){\r\n                src.shift()\r\n                let string = \"\"\r\n                while(src.length > 0 && src[0] != \"'\"){\r\n                    string += src.shift()\r\n                }\r\n                src.shift()\r\n                tokens.push(addToken(string, TokenType.String))\r\n            }\r\n            else if(checkNumber(src[0])){\r\n                let number = \"\"\r\n                while(src.length > 0 && checkNumber(src[0])){\r\n                    number += src.shift()\r\n                }\r\n                tokens.push(addToken(number, TokenType.Number))\r\n            }\r\n            else if(checkLetter(src[0])){\r\n                let identifier = \"\"\r\n                while(src.length > 0 && checkLetter(src[0]) || checkNumber(src[0])){\r\n                    identifier += src.shift()\r\n                }\r\n\r\n                const reserved = KEYWORDS[identifier]\r\n                if(typeof reserved == \"number\"){\r\n                    tokens.push(addToken(identifier, reserved))\r\n                }\r\n                else{\r\n                    tokens.push(addToken(identifier, TokenType.Identifier))\r\n                }\r\n            }\r\n            else if(src[0] === \" \" || src[0] === \"\\n\" || src[0] === \"\\t\" || src[0] === \"\\r\"){\r\n                src.shift()\r\n            }\r\n            else{\r\n                console.error(\"Unexpected token '\" + src[0] + \"' found\")\r\n                throw new Error(\"Unexpected token '\" + src[0] + \"' found\")\r\n            }\r\n        }\r\n    }\r\n    tokens.push({type: TokenType.EOF, value: \"EndOfFile\"})\r\n    return tokens\r\n}","import {Stmt, Program, Expr, BinaryExpr, NumericLiteral, Identifier, VarDeclaration, IfDeclaration, FunctionDeclaration, AssignmentExpr, Property, ObjectLiteral, CallExpr, MemberExpr, StringLiteral, ForDeclaration} from \"./ast\"\r\nimport { tokenize, Token, TokenType } from \"./lexer\"\r\n\r\nexport default class Parser{\r\n    private tokens: Token[] = []\r\n\r\n    private not_eof(): boolean{\r\n        return this.tokens[0].type != TokenType.EOF\r\n    }\r\n\r\n    private get(){\r\n        return this.tokens[0] as Token\r\n    }\r\n\r\n    private next(){\r\n        return this.tokens[1] as Token\r\n    }\r\n\r\n    private shift(){\r\n        const prev = this.tokens.shift() as Token\r\n        return prev\r\n    }\r\n\r\n    private expected(type: TokenType, err: string){\r\n        const prev = this.tokens.shift() as Token\r\n        if(!prev || prev.type != type){\r\n            console.error(\"Parser Error:\\n\", err, prev, \" - Expecting: \", type)\r\n            throw new Error(\"Parser Error:\\n\" +  err + \" \" + JSON.stringify(prev) + \" - Expecting: \" + type)\r\n        }\r\n        return prev\r\n    }\r\n\r\n    public produceAST(source: string): Program{\r\n        this.tokens = tokenize(source)\r\n        const program: Program = {\r\n            kind: \"Program\",\r\n            body: [],\r\n        }\r\n\r\n        // parse until end of file\r\n        while(this.not_eof()){\r\n            program.body.push(this.parse_stmt())\r\n        }\r\n\r\n        return program\r\n    }\r\n\r\n    private parse_stmt(): Stmt{\r\n        // skip to parse_expr\r\n        switch(this.get().type){\r\n            case TokenType.Let:\r\n            case TokenType.Const:\r\n                return this.parse_var_declaration()\r\n            case TokenType.Fn:\r\n                return this.parse_fn_declaration()\r\n            case TokenType.If:\r\n                return this.parse_if_stmt()\r\n            case TokenType.For:\r\n                return this.parse_for_stmt()\r\n            case TokenType.While:\r\n                return this.parse_if_stmt()\r\n            default:\r\n                return this.parse_expr()\r\n        }\r\n    }\r\n\r\n    private parse_for_stmt(): Stmt {\r\n        this.shift() // remove for\r\n\r\n        const name = this.expected(TokenType.Identifier, \"Expected for loop name following for keyword.\").value\r\n\r\n        this.expected(TokenType.OpenParen, \"Expected opening parentheses in for loop declaration.\")\r\n        const count = this.parse_additive_expr()\r\n        this.expected(TokenType.CloseParen, \"Missing closing parentheses in for loop decalration.\")\r\n\r\n        this.expected(TokenType.OpenBrace, \"Expected opening brace in for loop declaration.\")\r\n        const body: Stmt[] = []\r\n\r\n        while(this.get().type !== TokenType.EOF && this.get().type !== TokenType.CloseBrace){\r\n            body.push(this.parse_stmt())\r\n        }\r\n        this.expected(TokenType.CloseBrace, \"Expected closing brace in for loop declaration.\")\r\n        return {kind: \"ForDeclaration\", name, count, body} as ForDeclaration\r\n    }\r\n\r\n    private parse_fn_declaration(): Stmt {\r\n        this.shift() // remove fn keyword\r\n        const name = this.expected(TokenType.Identifier, \"Expected function name following fn keyword.\").value\r\n\r\n        const args = this.parse_args()\r\n        const params: string[] = []\r\n        for(const arg of args){\r\n            if(arg.kind !== \"Identifier\"){\r\n                throw new Error(\"Inside function declaration expected parameters to be of type string.\")\r\n            }\r\n\r\n            params.push((arg as Identifier).symbol)\r\n        }\r\n\r\n        this.expected(TokenType.OpenBrace, \"Expected function body following declaration.\")\r\n        const body: Stmt[] = []\r\n\r\n        while(this.get().type !== TokenType.EOF && this.get().type !== TokenType.CloseBrace){\r\n            body.push(this.parse_stmt())\r\n        }\r\n        this.expected(TokenType.CloseBrace, \"Closing brace expected inside function declaration.\")\r\n        const fn = {\r\n            body, \r\n            name, \r\n            parameters: params, \r\n            kind: \"FunctionDeclaration\"\r\n        } as FunctionDeclaration\r\n\r\n        return fn\r\n    }\r\n\r\n    private parse_var_declaration(): Stmt{\r\n        const isConstant = this.shift().type == TokenType.Const\r\n        const identifier = this.expected(TokenType.Identifier, \"Expected identifier name following let | const keywords.\").value\r\n        \r\n        // if(this.get().type == TokenType.Semicolon){\r\n        //     this.shift() //expect semicolon\r\n        //     if(isConstant){\r\n        //         throw new Error(\"Must assigne value to constant expression. No value provided.\")\r\n        //     }\r\n        //     return {kind: \"VarDeclaration\", identifier, constant: false} as VarDeclaration\r\n        // }\r\n        this.expected(TokenType.Equals, \"Expected equals token following identifier in var declaration.\")\r\n        const declaration = {kind: \"VarDeclaration\", identifier, value: this.parse_expr(), constant: isConstant} as VarDeclaration\r\n    \r\n        // this.expected(TokenType.Semicolon, \"Variable declaration statement must end with semicolon.\")\r\n        return declaration\r\n    }\r\n\r\n    private parse_if_stmt(): Stmt{\r\n        this.shift() // remove if\r\n        this.expected(TokenType.OpenParen, \"Expected opening parantheses in if statement.\")\r\n\r\n        const condition = this.parse_condition_expr()\r\n        // console.log(\"condition\")\r\n        // console.dir(condition, {depth: 3})\r\n\r\n        this.expected(TokenType.CloseParen, \"Missing closing parantheses in if statement.\")\r\n\r\n        this.expected(TokenType.OpenBrace, \"Expected function body following if statement declaration.\")\r\n        const body:Stmt[] = []\r\n\r\n        while(this.get().type !== TokenType.EOF && this.get().type !== TokenType.CloseBrace){\r\n            body.push(this.parse_stmt())\r\n        }\r\n        this.expected(TokenType.CloseBrace, \"Closing brace expected inside if statement declaration.\")\r\n\r\n        if(this.get().type == TokenType.Else && this.next().type == TokenType.If){\r\n            this.shift() // remove else\r\n            \r\n            const elseIfDeclaration = this.parse_if_stmt()\r\n\r\n            return {kind: \"IfDeclaration\", condition, body, elseIfDeclaration} as IfDeclaration\r\n        }\r\n        else if(this.get().type == TokenType.Else){\r\n            this.shift() // remove else\r\n            let elseBody:Stmt[] = []\r\n            this.expected(TokenType.OpenBrace, \"Expected function body following if statement declaration.\")\r\n            while(this.get().type !== TokenType.EOF && this.get().type !== TokenType.CloseBrace){\r\n                elseBody.push(this.parse_stmt())\r\n            }\r\n            this.expected(TokenType.CloseBrace, \"Closing brace expected inside if statement declaration.\")\r\n\r\n            return {kind: \"IfDeclaration\", condition, body, elseBody} as IfDeclaration\r\n\r\n        }\r\n        else console.log(\"no else condition defined\")\r\n\r\n        return {kind: \"IfDeclaration\", condition, body} as IfDeclaration\r\n    }\r\n\r\n    // presidence\r\n    // Assignment\r\n    // Object\r\n    // Additve\r\n    // Multiplicative\r\n    // Call\r\n    // Member\r\n    // Primary Expression\r\n\r\n    private parse_expr(): Expr{\r\n        return this.parse_assignment_expr()\r\n    }\r\n\r\n    private parse_assignment_expr(): Expr {\r\n        const left = this.parse_object_expr()\r\n\r\n        if(this.get().type == TokenType.Equals){\r\n            this.shift()\r\n            const value = this.parse_assignment_expr()\r\n            return {value, assigne: left, kind: \"AssignmentExpr\"} as AssignmentExpr\r\n        }\r\n        return left\r\n    }\r\n\r\n    private parse_object_expr(): Expr {\r\n        if(this.get().type !== TokenType.OpenBrace){\r\n            return this.parse_additive_expr()\r\n        }\r\n\r\n        this.shift()\r\n        const properties = new Array<Property>()\r\n\r\n        while(this.not_eof() && this.get().type != TokenType.CloseBrace){\r\n            const key = this.expected(TokenType.Identifier, \"Object literal key expected\").value\r\n\r\n            // allows shorthand ({key, short...})\r\n            if(this.get().type == TokenType.Comma){\r\n                this.shift()\r\n                properties.push({key, kind: \"Property\"} as Property)\r\n                continue\r\n            }\r\n            else if(this.get().type == TokenType.CloseBrace){\r\n                properties.push({key, kind: \"Property\"})\r\n                continue\r\n            }\r\n\r\n            this.expected(TokenType.Colon, \"Missing colon following identifier in Object literal\")\r\n            const value = this.parse_stmt()\r\n\r\n            properties.push({kind: \"Property\", value, key})\r\n            if(this.get().type != TokenType.CloseBrace){\r\n                this.expected(TokenType.Comma, \"Expected comma or closing brace following property\")\r\n            }\r\n        }\r\n\r\n        this.expected(TokenType.CloseBrace, \"Object literal missing closing brace.\")\r\n        return {kind: \"ObjectLiteral\", properties} as ObjectLiteral\r\n    }\r\n\r\n    private parse_condition_expr(): Expr{\r\n        let left = this.parse_additive_expr()\r\n        const comperator = this.get();\r\n        while(\r\n            comperator.type == TokenType.AmpersandOperator ||\r\n            comperator.type == TokenType.VerticalBarOperator ||\r\n            comperator.type == TokenType.EqualsComperator ||\r\n            comperator.type == TokenType.NotEqualsComperator ||\r\n            comperator.type == TokenType.GreaterComperator ||\r\n            comperator.type == TokenType.LessComperator ||\r\n            comperator.type == TokenType.NotGreaterComperator ||\r\n            comperator.type == TokenType.NotLessComperator\r\n        ){\r\n            if(this.get().type == TokenType.CloseParen) return left\r\n            const operator = this.shift()\r\n            let right:any\r\n            if(operator.type == TokenType.VerticalBarOperator || operator.type == TokenType.AmpersandOperator){\r\n                right = this.parse_condition_expr()\r\n            }\r\n            else right = this.parse_additive_expr()\r\n            left = {\r\n                kind: \"BinaryExpr\",\r\n                left,\r\n                right,\r\n                operator,\r\n            } as BinaryExpr\r\n        }\r\n        return left\r\n    }\r\n\r\n    private parse_additive_expr(): Expr{\r\n        let left = this.parse_multiplicative_expr()\r\n\r\n        while(this.get().value == \"+\" || this.get().value == \"-\"){\r\n            const operator = this.shift()\r\n            const right = this.parse_multiplicative_expr()\r\n            left = {\r\n                kind: \"BinaryExpr\",\r\n                left,\r\n                right,\r\n                operator\r\n            } as BinaryExpr\r\n        }\r\n        return left\r\n    }\r\n\r\n    private parse_multiplicative_expr(): Expr{\r\n        let left = this.parse_call_member_expr()\r\n\r\n        while(this.get().value == \"*\" || this.get().value == \"/\" || this.get().value == \"%\"){\r\n            const operator = this.shift()\r\n            const right = this.parse_call_member_expr()\r\n            left = {\r\n                kind: \"BinaryExpr\",\r\n                left,\r\n                right,\r\n                operator\r\n            } as BinaryExpr\r\n        }\r\n        return left\r\n    }\r\n\r\n    private parse_call_member_expr(): Expr{\r\n        const member = this.parse_member_expr()\r\n\r\n        if(this.get().type == TokenType.OpenParen){\r\n            return this.parse_call_expr(member)\r\n        }\r\n        else{\r\n            return member\r\n        }\r\n    }\r\n\r\n    private parse_call_expr(caller: Expr): Expr{\r\n        let call_expr: Expr = {\r\n            kind: \"CallExpr\",\r\n            caller,\r\n            args: this.parse_args()\r\n        } as CallExpr\r\n\r\n        if(this.get().type == TokenType.OpenParen){\r\n            call_expr = this.parse_call_expr(call_expr)\r\n        }\r\n\r\n        return call_expr\r\n    }\r\n\r\n    private parse_args(): Expr[]{\r\n        this.expected(TokenType.OpenParen, \"Expected open paranthesis.\")\r\n        const args = this.get().type == TokenType.CloseParen ? [] : this.parse_arguments_list_expr()\r\n        this.expected(TokenType.CloseParen, \"Missing closing parenthesis inside arguments list.\")\r\n        return args\r\n    }\r\n\r\n    private parse_arguments_list_expr(): Expr[]{\r\n        const args = [this.parse_assignment_expr()]\r\n\r\n        while(this.get().type == TokenType.Comma && this.shift()){\r\n            args.push(this.parse_assignment_expr())\r\n        }\r\n\r\n        return args\r\n    }\r\n\r\n    private parse_member_expr(): Expr{\r\n        let object = this.parse_unary_expr()\r\n\r\n        while(this.get().type == TokenType.Dot || this.get().type == TokenType.OpenBracket){\r\n            const operator = this.shift()\r\n            let property: Expr\r\n            let computed: boolean\r\n\r\n            // non-computed values aka obj.expr\r\n            if(operator.type == TokenType.Dot){\r\n                computed = false\r\n                property = this.parse_primary_expr() // get identifier\r\n\r\n                if(property.kind != \"Identifier\"){\r\n                    throw new Error(\"Cannot use dot operator without right hand side being an identifier.\")\r\n                }\r\n            }\r\n            else{ // this allows obj[computedValue]\r\n                computed = true\r\n                property = this.parse_expr()\r\n                this.expected(TokenType.CloseBracket, \"Missing closing bracket in computed value.\")\r\n            }\r\n\r\n            object = {kind: \"MemberExpr\", object, property, computed} as MemberExpr\r\n        }\r\n\r\n        return object\r\n    }\r\n\r\n    private parse_unary_expr(): Expr{\r\n        if(this.get().type == TokenType.ExclamationMark){\r\n            this.shift()\r\n            const left = this.parse_additive_expr()\r\n            const right = this.parse_additive_expr()\r\n            return {kind: \"BinaryExpr\", left, right, operator: {type: TokenType.NotEqualsComperator, value: \"!\"} as Token} as BinaryExpr\r\n        }\r\n        else return this.parse_primary_expr()\r\n    }\r\n\r\n    private parse_primary_expr(): Expr{\r\n        const tk = this.get().type\r\n\r\n        switch(tk){\r\n            case TokenType.Identifier:\r\n                return {kind: \"Identifier\", symbol: this.shift().value } as Identifier\r\n            case TokenType.Number:\r\n                return {kind: \"NumericLiteral\", value: parseFloat(this.shift().value) } as NumericLiteral\r\n            case TokenType.String:\r\n                return {kind: \"StringLiteral\", value: this.shift().value } as StringLiteral\r\n            case TokenType.OpenParen:\r\n                this.shift()\r\n                const value = this.parse_expr()\r\n                this.expected(TokenType.CloseParen, \"Unexpected token found inside parenthesised expression. Expected closing parenthes\")\r\n                return value\r\n            default:\r\n                console.error(\"Unexpected token \", this.get(), \" found during parsing\")\r\n                throw new Error(\"Unexpected token \" + JSON.stringify(this.get()) + \" found during parsing\")\r\n        }\r\n    }\r\n}","import { Expr, Stmt } from \"./ast\"\r\nimport Environment from \"./environment\"\r\n\r\nexport type ValueType = \"null\" | \"number\" | \"string\" | \"boolean\" | \"object\" | \"nativeFn\" | \"function\" | \"member\" | \"if\"\r\n\r\nexport interface RuntimeValue {\r\n    type: ValueType\r\n}\r\n\r\nexport interface NullValue extends RuntimeValue {\r\n    type: \"null\"\r\n    value: null\r\n}\r\n\r\nexport function create_null(){\r\n    return {type: \"null\", value: null} as NullValue\r\n}\r\n\r\nexport interface BooleanValue extends RuntimeValue {\r\n    type: \"boolean\"\r\n    value: boolean\r\n}\r\n\r\nexport function create_bool(value = true){\r\n    return {type: \"boolean\", value} as BooleanValue\r\n}\r\n\r\nexport interface NumberValue extends RuntimeValue {\r\n    type: \"number\"\r\n    value: number\r\n}\r\n\r\nexport function create_number(value = 0){\r\n    return {type: \"number\", value} as NumberValue\r\n}\r\n\r\nexport interface StringValue extends RuntimeValue {\r\n    type: \"string\"\r\n    value: string\r\n}\r\n\r\nexport function create_string(value = \"\"){\r\n    return {type: \"string\", value} as StringValue\r\n}\r\n\r\nexport interface ObjectValue extends RuntimeValue {\r\n    type: \"object\"\r\n    properties: Map<string, RuntimeValue>\r\n}\r\n\r\nexport type FunctionCall = (args: RuntimeValue[], env: Environment) => RuntimeValue\r\n\r\nexport interface NativeFnValue extends RuntimeValue {\r\n    type: \"nativeFn\"\r\n    call: FunctionCall\r\n}\r\n\r\nexport function create_nativeFn(call: FunctionCall){\r\n    return { type: \"nativeFn\", call} as NativeFnValue\r\n}\r\n\r\nexport interface FunctionValue extends RuntimeValue {\r\n    type: \"function\"\r\n    name: string,\r\n    parameters: string[]\r\n    declarationEnv: Environment\r\n    body: Stmt[]\r\n}","import Environment from \"./environment\";\r\nimport { BooleanValue, FunctionValue, NativeFnValue, NullValue, NumberValue, ObjectValue, RuntimeValue, StringValue, create_null, create_string } from \"./values\";\r\n\r\n\r\nexport default class Natives{\r\n    public log(args: RuntimeValue[], scope: Environment): RuntimeValue {\r\n        let finalLog:string = \"\"\r\n        for(const arg of args){\r\n            if(arg.type == \"string\"){\r\n                finalLog += (arg as StringValue).value\r\n            }\r\n            else if(arg.type == \"number\"){\r\n                finalLog += (arg as NumberValue).value.toString()\r\n            }\r\n            else if(arg.type == \"boolean\"){\r\n                finalLog += (arg as BooleanValue).value.toString()\r\n            }\r\n            else {\r\n                console.log(finalLog)\r\n                console.log(arg)\r\n                return create_null()\r\n            }\r\n            finalLog += \"   \"\r\n        }\r\n        console.log(finalLog)\r\n        return create_null()\r\n    }\r\n    public upper(args: RuntimeValue[], scope: Environment): RuntimeValue {\r\n        let result: RuntimeValue = create_null()\r\n        if(args[0].type == \"string\"){\r\n            result = create_string((args[0] as StringValue).value.toUpperCase())\r\n        }\r\n        else{\r\n            throw new Error(\"Cannot use \" + args[0].type + \" for translation into an upper case letter.\")\r\n        }\r\n        return result\r\n    }\r\n    public lower(args: RuntimeValue[], scope: Environment): RuntimeValue {\r\n        let result: RuntimeValue = create_null()\r\n        if(args[0].type == \"string\"){\r\n            result = create_string((args[0] as StringValue).value.toLowerCase())\r\n        }\r\n        else{\r\n            throw new Error(\"Cannot use \" + args[0].type + \" for translation into an upper case letter.\")\r\n        }\r\n        return result\r\n    }\r\n}","import { RuntimeValue, create_bool, create_nativeFn, create_null, create_number } from \"./values\"\r\nimport Natives from \"./natives\";\r\n\r\nexport function createGlobalEnvironment(){\r\n    const natives = new Natives()\r\n    const env = new Environment()\r\n\r\n    // default variables\r\n    env.declareVar(\"true\", create_bool(true), true)\r\n    env.declareVar(\"false\", create_bool(false), true)\r\n    env.declareVar(\"null\", create_null(), true)\r\n\r\n    // natives functions\r\n    env.declareVar(\"log\", create_nativeFn(natives.log), true)\r\n    env.declareVar(\"upper\", create_nativeFn(natives.upper), true)\r\n    env.declareVar(\"lower\", create_nativeFn(natives.lower), true)\r\n    env.declareVar(\"time\", create_number(Date.now()), true)\r\n\r\n    return env\r\n}\r\n\r\nexport default class Environment{\r\n    private parent?: Environment\r\n    private variables: Map<string, RuntimeValue>\r\n    private constants: Set<string>\r\n\r\n    constructor(parentENV?: Environment){\r\n        this.parent = parentENV\r\n        this.variables = new Map()\r\n        this.constants = new Set() \r\n    }\r\n\r\n    public declareVar(varname: string, value: RuntimeValue, constant: boolean): RuntimeValue{\r\n        if(this.variables.has(varname)){\r\n            throw new Error(\"Cannot declare variable \" + varname + \". As it already is defined.\")\r\n        }\r\n\r\n        this.variables.set(varname, value)\r\n\r\n        if(constant) this.constants.add(varname)\r\n        return value\r\n    }\r\n\r\n    public assignVar(varname: string, value: RuntimeValue): RuntimeValue{\r\n        const env = this.resolve(varname)\r\n\r\n        if(env.constants.has(varname)){\r\n            throw new Error(\"Cannot reassign to variable \" + varname + \" as it was declared as constant.\")\r\n        }\r\n\r\n        env.variables.set(varname, value)\r\n        return value\r\n    }\r\n\r\n    public lookupVar(varname: string): RuntimeValue{\r\n        const env = this.resolve(varname)\r\n        return env.variables.get(varname) as RuntimeValue\r\n    }\r\n\r\n    public resolve(varname: string): Environment{\r\n        if(this.variables.has(varname)) return this\r\n        if(this.parent == undefined) throw new Error(\"Cannot resolve \" + varname + \" as it does not exist.\")\r\n        return this.parent.resolve(varname)\r\n    }\r\n}","import { AssignmentExpr, BinaryExpr, CallExpr, Expr, Identifier, MemberExpr, ObjectLiteral, StringLiteral } from \"./ast\"\r\nimport Environment from \"./environment\"\r\nimport { interpret } from \"./interpreter\"\r\nimport { Token, TokenType } from \"./lexer\"\r\nimport { BooleanValue, FunctionValue, NativeFnValue, NumberValue, ObjectValue, RuntimeValue, StringValue, create_nativeFn, create_null } from \"./values\"\r\n\r\n\r\n\r\nexport function interpret_binary_expr(binop: BinaryExpr, env: Environment): RuntimeValue{\r\n    const lhs = interpret(binop.left, env)\r\n    const rhs = interpret(binop.right, env)\r\n\r\n    if(binop.operator.type == TokenType.AmpersandOperator || binop.operator.type == TokenType.VerticalBarOperator || binop.operator.type == TokenType.EqualsComperator || binop.operator.type == TokenType.NotEqualsComperator || binop.operator.type == TokenType.LessComperator || binop.operator.type == TokenType.GreaterComperator || binop.operator.type == TokenType.NotLessComperator || binop.operator.type == TokenType.NotGreaterComperator){\r\n        return interpret_condition_binary_expr(lhs, rhs, binop.operator)\r\n    }\r\n    if(lhs.type == \"number\" && rhs.type == \"number\"){\r\n        return interpret_numeric_binary_expr(lhs as NumberValue, rhs as NumberValue, binop.operator)\r\n    }\r\n    if(lhs.type == \"string\" && rhs.type == \"string\" && binop.operator.value == \"+\"){\r\n        return interpret_string_binary_expr(lhs as StringValue, rhs as StringValue)\r\n    }\r\n\r\n    return create_null()\r\n}\r\n\r\nexport function interpret_condition_binary_expr(lhs: RuntimeValue, rhs: RuntimeValue, operator: Token): BooleanValue{\r\n    if(operator.type == TokenType.EqualsComperator){\r\n        if(lhs == rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.NotEqualsComperator){\r\n        if(lhs != rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.GreaterComperator){\r\n        if(lhs > rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.LessComperator){\r\n        if(lhs > rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.NotLessComperator){\r\n        if(lhs !< rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.NotGreaterComperator){\r\n        if(lhs !> rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.AmpersandOperator){\r\n        if(lhs && rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else if(operator.type == TokenType.VerticalBarOperator){\r\n        if(lhs || rhs){\r\n            return {type: \"boolean\", value: true} as BooleanValue\r\n        }\r\n        else return {type: \"boolean\", value: false} as BooleanValue\r\n    }\r\n    else return {type: \"boolean\", value: false} as BooleanValue\r\n}\r\n\r\nexport function interpret_string_binary_expr(lhs: StringValue, rhs: StringValue): StringValue{\r\n    const result = lhs.value + rhs.value\r\n    return { type: \"string\", value: result} as StringValue\r\n}\r\n\r\nexport function interpret_numeric_binary_expr(lhs: NumberValue, rhs: NumberValue, operator: Token): NumberValue{\r\n    let result = 0\r\n    if(operator.value == \"+\") result = lhs.value + rhs.value\r\n    else if(operator.value == \"-\") result = lhs.value - rhs.value\r\n    else if(operator.value == \"*\") result = lhs.value + rhs.value\r\n    else if(operator.value == \"/\") result = lhs.value / rhs.value\r\n    else if(operator.value == \"%\") result = lhs.value % rhs.value\r\n    else throw new Error(\"The operator \" + operator.value + \" was not setup for interpretation in numeric binary expressions.\")\r\n    return { type: \"number\", value: result} as NumberValue\r\n}\r\n\r\nexport function interpret_identifier(identifier: Identifier, env: Environment): RuntimeValue{\r\n    const value = env.lookupVar(identifier.symbol)\r\n    return value\r\n}\r\n\r\nexport function interpret_object_expr(obj: ObjectLiteral, env: Environment): RuntimeValue{\r\n    const object = { type: \"object\", properties: new Map()} as ObjectValue\r\n\r\n    for(const {key, value} of obj.properties){\r\n        // handle valid key: pair\r\n        const runtimeValue = (value == undefined) ? env.lookupVar(key) : interpret(value, env)\r\n\r\n        object.properties.set(key, runtimeValue)\r\n    }\r\n\r\n    return object\r\n}\r\n\r\nexport function interpret_member_expr(expr: MemberExpr, env: Environment): RuntimeValue{\r\n    const lhs = interpret(expr.object, env)\r\n    if(lhs.type == \"object\"){\r\n        const obj = lhs as ObjectValue\r\n        let value:any\r\n        if(expr.computed){\r\n            let computedValue:any\r\n            if(expr.property.kind == \"StringLiteral\") value = obj.properties.get((expr.property as StringLiteral).value)\r\n            else{\r\n                computedValue = interpret(expr.property, env)\r\n                if(!computedValue){\r\n                    console.error(\"Cannot interpret member expression: \", expr.property)\r\n                    throw new Error(\"Cannot interpret member expression: \" + JSON.stringify(expr.property))\r\n                } \r\n                value = obj.properties.get((computedValue as StringLiteral).value)\r\n            } \r\n        }\r\n        else{\r\n            if(expr.property.kind == \"Identifier\") value = obj.properties.get((expr.property as Identifier).symbol)\r\n        }\r\n        if(!value) value = create_null()\r\n        return value\r\n    }\r\n    return lhs\r\n}\r\n\r\nexport function interpret_call_expr(expr: CallExpr, env: Environment): RuntimeValue{\r\n    const args = expr.args.map((arg) => interpret(arg, env))\r\n    const fn = interpret(expr.caller, env)\r\n\r\n    if(fn.type == \"nativeFn\"){     \r\n        const result = (fn as NativeFnValue).call(args, env)\r\n        return result\r\n    }\r\n    \r\n    if(fn.type == \"function\"){\r\n        const func = fn as FunctionValue\r\n        const scope = new Environment(func.declarationEnv)\r\n\r\n        for (let i = 0; i < func.parameters.length; i++) {\r\n            if(func.parameters.length < args.length){\r\n                throw new Error(\"Cannot assign more arguments than the function can handle: parameters: \" + func.parameters.length + \" passed arguments: \" + args.length)\r\n            }\r\n            else if(func.parameters.length > args.length)\r\n            {\r\n                throw new Error(\"Cannot assign less arguments than the function handles: needed paramters: \" + func.parameters.length)\r\n            }\r\n            const varname = func.parameters[i];\r\n            scope.declareVar(varname, args[i], false)\r\n        }\r\n\r\n        let result: RuntimeValue = create_null()\r\n        // interpret the function body line by line\r\n        for(const stmt of func.body){\r\n            result = interpret(stmt, scope)\r\n        }\r\n        return result\r\n    } \r\n\r\n    console.error(\"Cannot call value that is not a function: \", fn)\r\n    throw new Error(\"Cannot call value that is not a function: \" + JSON.stringify(fn))\r\n}\r\n\r\nexport function interpret_assignment(node: AssignmentExpr, env: Environment): RuntimeValue{\r\n    if(node.assigne.kind !== \"Identifier\"){\r\n        console.error(\"Invalid value for an assingment expression \", node.assigne)\r\n        throw new Error(\"Invalid value for an assingment expression \" + JSON.stringify(node.assigne))\r\n    }\r\n\r\n    const varname = (node.assigne as Identifier).symbol\r\n    return env.assignVar(varname, interpret(node.value, env))\r\n}","import { BinaryExpr, ForDeclaration, FunctionDeclaration, IfDeclaration, NumericLiteral, Program, VarDeclaration } from \"./ast\"\r\nimport Environment from \"./environment\"\r\nimport { interpret } from \"./interpreter\"\r\nimport { BooleanValue, FunctionValue, RuntimeValue, create_null } from \"./values\"\r\n\r\n\r\n\r\nexport function interpret_program(program: Program, env: Environment): RuntimeValue{\r\n    let lastInterpreted: RuntimeValue = create_null()\r\n\r\n    for(const statement of program.body){\r\n        lastInterpreted = interpret(statement, env)\r\n    }\r\n    return lastInterpreted\r\n}\r\n\r\nexport function interpret_var_declaration(declaration: VarDeclaration, env: Environment): RuntimeValue{\r\n    const value = declaration.value ? interpret(declaration.value, env) : create_null()\r\n    return env.declareVar(declaration.identifier, value, declaration.constant)\r\n}\r\n\r\nexport function interpret_fn_declaration(declaration: FunctionDeclaration, env: Environment): RuntimeValue{\r\n    const fn = {\r\n        type: \"function\",\r\n        name: declaration.name,\r\n        parameters: declaration.parameters,\r\n        declarationEnv: env,\r\n        body: declaration.body\r\n    } as FunctionValue\r\n\r\n    return env.declareVar(declaration.name, fn, true)\r\n}\r\n\r\nexport function interpret_if_declaration(declaration: IfDeclaration, env: Environment): RuntimeValue{\r\n    //console.dir(declaration, {depth: null})\r\n    const value = interpret(declaration.condition, env)\r\n    if((value as BooleanValue).value == true){\r\n        let result: RuntimeValue = create_null()\r\n        // interpret the function body line by line\r\n        for(const stmt of declaration.body){\r\n            result = interpret(stmt, env)\r\n        }\r\n        return result\r\n    }\r\n    else if(declaration.elseIfDeclaration){\r\n        const elseValue = interpret_if_declaration(declaration.elseIfDeclaration, env)\r\n        return elseValue\r\n    }\r\n    else if(declaration.elseBody){\r\n        let result: RuntimeValue = create_null()\r\n        // interpret the function body line by line\r\n        for(const stmt of declaration.elseBody){\r\n            result = interpret(stmt, env)\r\n        }\r\n        return result\r\n    }\r\n    else{\r\n        return create_null()\r\n    } \r\n}\r\n\r\nexport function interpret_for_declaration(declaration: ForDeclaration, env: Environment): RuntimeValue{\r\n    if(declaration.count.kind == \"NumericLiteral\"){\r\n        let result:any\r\n        for(let i = 0; i < (declaration.count as NumericLiteral).value; i++){\r\n            for(const stmt of declaration.body){\r\n                result = interpret(stmt, env)\r\n            }\r\n        }\r\n        return result\r\n    }\r\n    else{\r\n        console.log(\"Count in interpretation of for declaration was not a numeric literal: \", declaration.count)\r\n        return create_null()\r\n    }\r\n}\r\n","import { ValueType, RuntimeValue, NumberValue, NullValue, create_null, StringValue} from \"./values\"\r\nimport { AssignmentExpr, BinaryExpr, CallExpr, ForDeclaration, FunctionDeclaration, Identifier, IfDeclaration, MemberExpr, NodeType, NumericLiteral, ObjectLiteral, Program, Stmt, StringLiteral, VarDeclaration} from \"./ast\"\r\nimport Environment from \"./environment\"\r\nimport { interpret_assignment, interpret_binary_expr, interpret_call_expr, interpret_identifier, interpret_object_expr, interpret_member_expr } from \"./expressions\"\r\nimport { interpret_program, interpret_var_declaration, interpret_fn_declaration, interpret_if_declaration, interpret_for_declaration } from \"./statements\"\r\n\r\nexport function interpret(astNode: Stmt, env: Environment): RuntimeValue {\r\n\r\n    switch(astNode.kind){\r\n        case \"NumericLiteral\":\r\n            return {value: ((astNode as NumericLiteral).value), type: \"number\"} as NumberValue\r\n        case \"StringLiteral\":\r\n            return {value: ((astNode as StringLiteral).value), type: \"string\"} as StringValue\r\n        case \"Identifier\":\r\n            return interpret_identifier(astNode as Identifier, env)\r\n        case \"ObjectLiteral\":\r\n            return interpret_object_expr(astNode as ObjectLiteral, env)\r\n        case \"CallExpr\":\r\n            return interpret_call_expr(astNode as CallExpr, env)\r\n        case \"MemberExpr\":\r\n            return interpret_member_expr(astNode as MemberExpr, env)\r\n        case \"BinaryExpr\":\r\n            return interpret_binary_expr(astNode as BinaryExpr, env)\r\n        case \"AssignmentExpr\":\r\n            return interpret_assignment(astNode as AssignmentExpr, env)\r\n        case \"Program\":\r\n            return interpret_program(astNode as Program, env)\r\n        case \"VarDeclaration\":\r\n            return interpret_var_declaration(astNode as VarDeclaration, env)\r\n        case \"FunctionDeclaration\":\r\n            return interpret_fn_declaration(astNode as FunctionDeclaration, env)\r\n        case \"IfDeclaration\":\r\n            return interpret_if_declaration(astNode as IfDeclaration, env)\r\n        case \"ForDeclaration\":\r\n            return interpret_for_declaration(astNode as ForDeclaration, env)\r\n        default:\r\n            console.error(\"This AST Node has not yet been setup for interpretation: \", astNode)\r\n            throw new Error(\"This AST Node has not yet been setup for interpretation: \" + JSON.stringify(astNode))\r\n    }\r\n}","import Parser from \"./parser\";\r\nimport {interpret} from \"./interpreter\";\r\nimport {createGlobalEnvironment} from \"./environment\";\r\nimport * as fs from \"fs\";\r\n\r\n/**\r\n * This method runs the complete programming language, to read your `input` / `code`, parse it and interpret it, so you can get an `output` / `result` about your `program`.\r\n * @param {string} inputSource is the `path` to the file, where your `input` / `code` is existing in\r\n */\r\nexport async function runLanguage(inputSource: string) {\r\n    const env = createGlobalEnvironment()\r\n\r\n    console.log(\"\\nLanguage v0.1\\n\")\r\n\r\n    const input = fs.readFileSync(inputSource).toString()\r\n    \r\n    const parser = new Parser()\r\n    const program = parser.produceAST(input)\r\n    //console.log(\"main.ts: program:\\n\", program)\r\n\r\n    const result = interpret(program, env)\r\n    // console.log(\"main.ts: result:\\n\", result)\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,SAAS,YAAY,GAAU;AAC3B,SAAO,YAAY,KAAK,CAAC;AAC7B;AACA,SAAS,YAAY,GAAU;AAC3B,SAAO,SAAS,KAAK,CAAC;AAC1B;AAkDA,IAAM,WAAsC;AAAA,EACxC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,SAAS;AACb;AAEA,SAAS,SAAS,QAAQ,IAAI,MAAgB;AAC1C,SAAO,EAAC,OAAO,KAAI;AACvB;AAUO,SAAS,SAAS,MAAsB;AAC3C,QAAM,SAAS,IAAI,MAAa;AAChC,QAAM,MAAM,KAAK,MAAM,EAAE;AAEzB,SAAM,IAAI,SAAS,GAAE;AACjB,QAAG,IAAI,CAAC,MAAM,KAAI;AACd,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,iBAAmB,CAAC;AAAA,IAC1D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,kBAAoB,CAAC;AAAA,IAC3D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,iBAAmB,CAAC;AAAA,IAC1D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,kBAAoB,CAAC;AAAA,IAC3D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,mBAAqB,CAAC;AAAA,IAC5D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,oBAAsB,CAAC;AAAA,IAC7D,WACQ,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,KAAI;AACrC,UAAI,MAAM;AACV,UAAI,MAAM;AACV,aAAM,IAAI,SAAS,GAAE;AACjB,YAAG,IAAI,MAAM,KAAK,OAAO,IAAI,MAAM,KAAK;AAAK;AAAA;AACxC;AAAA,MACT;AAAA,IACJ,WACQ,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,KAAI;AACrC,UAAI,MAAM;AACV,UAAI,MAAM;AACV,aAAM,IAAI,SAAS,KAAK,IAAI,MAAM,KAAK,MAAK;AACxC;AAAA,MACJ;AAAA,IACJ,WACQ,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,KAAI;AAC3F,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,uBAAwB,CAAC;AAAA,IAC/D,WACQ,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,KAAI;AACrC,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,eAAgB,CAAC;AAAA,IACvD,WAIQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,cAAe,CAAC;AAAA,IACtD,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,cAAe,CAAC;AAAA,IACtD,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,YAAa,CAAC;AAAA,IACpD,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,0BAA2B,CAAC;AAAA,IAClE,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,aAAO,KAAK,SAAS,IAAI,MAAM,GAAG,uBAAwB,CAAC;AAAA,IAC/D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,UAAI,MAAM;AACV,aAAO,KAAK,SAAS,KAAK,4BAA6B,CAAC;AAAA,IAC5D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,UAAI,MAAM;AACV,aAAO,KAAK,SAAS,KAAK,0BAA2B,CAAC;AAAA,IAC1D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,UAAG,IAAI,CAAC,MAAM,KAAI;AACd,YAAI,MAAM;AACV,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,MAAM,yBAA0B,CAAC;AAAA,MAC1D;AAAA,IACJ,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,UAAG,IAAI,CAAC,MAAM,KAAI;AACd,YAAI,MAAM;AACV,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,MAAM,4BAA6B,CAAC;AAAA,MAC7D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,YAAI,MAAM;AACV,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,MAAM,0BAA2B,CAAC;AAAA,MAC3D,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,YAAI,MAAM;AACV,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,MAAM,6BAA8B,CAAC;AAAA,MAC9D,OACI;AACA,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,KAAK,wBAAyB,CAAC;AAAA,MACxD;AAAA,IACJ,OACI;AACA,UAAG,IAAI,CAAC,MAAM,KAAK;AACf,YAAI,MAAM;AACV,YAAI,SAAS;AACb,eAAM,IAAI,SAAS,KAAK,IAAI,CAAC,KAAK,KAAK;AACnC,oBAAU,IAAI,MAAM;AAAA,QACxB;AACA,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,QAAQ,cAAgB,CAAC;AAAA,MAClD,WACQ,IAAI,CAAC,MAAM,KAAI;AACnB,YAAI,MAAM;AACV,YAAI,SAAS;AACb,eAAM,IAAI,SAAS,KAAK,IAAI,CAAC,KAAK,KAAI;AAClC,oBAAU,IAAI,MAAM;AAAA,QACxB;AACA,YAAI,MAAM;AACV,eAAO,KAAK,SAAS,QAAQ,cAAgB,CAAC;AAAA,MAClD,WACQ,YAAY,IAAI,CAAC,CAAC,GAAE;AACxB,YAAI,SAAS;AACb,eAAM,IAAI,SAAS,KAAK,YAAY,IAAI,CAAC,CAAC,GAAE;AACxC,oBAAU,IAAI,MAAM;AAAA,QACxB;AACA,eAAO,KAAK,SAAS,QAAQ,cAAgB,CAAC;AAAA,MAClD,WACQ,YAAY,IAAI,CAAC,CAAC,GAAE;AACxB,YAAI,aAAa;AACjB,eAAM,IAAI,SAAS,KAAK,YAAY,IAAI,CAAC,CAAC,KAAK,YAAY,IAAI,CAAC,CAAC,GAAE;AAC/D,wBAAc,IAAI,MAAM;AAAA,QAC5B;AAEA,cAAM,WAAW,SAAS,UAAU;AACpC,YAAG,OAAO,YAAY,UAAS;AAC3B,iBAAO,KAAK,SAAS,YAAY,QAAQ,CAAC;AAAA,QAC9C,OACI;AACA,iBAAO,KAAK,SAAS,YAAY,kBAAoB,CAAC;AAAA,QAC1D;AAAA,MACJ,WACQ,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM,QAAQ,IAAI,CAAC,MAAM,OAAQ,IAAI,CAAC,MAAM,MAAK;AAC5E,YAAI,MAAM;AAAA,MACd,OACI;AACA,gBAAQ,MAAM,uBAAuB,IAAI,CAAC,IAAI,SAAS;AACvD,cAAM,IAAI,MAAM,uBAAuB,IAAI,CAAC,IAAI,SAAS;AAAA,MAC7D;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,KAAK,EAAC,MAAM,cAAe,OAAO,YAAW,CAAC;AACrD,SAAO;AACX;;;ACvOA,IAAqB,SAArB,MAA2B;AAAA,EAA3B;AACI,SAAQ,SAAkB,CAAC;AAAA;AAAA,EAEnB,UAAkB;AACtB,WAAO,KAAK,OAAO,CAAC,EAAE;AAAA,EAC1B;AAAA,EAEQ,MAAK;AACT,WAAO,KAAK,OAAO,CAAC;AAAA,EACxB;AAAA,EAEQ,OAAM;AACV,WAAO,KAAK,OAAO,CAAC;AAAA,EACxB;AAAA,EAEQ,QAAO;AACX,UAAM,OAAO,KAAK,OAAO,MAAM;AAC/B,WAAO;AAAA,EACX;AAAA,EAEQ,SAAS,MAAiB,KAAY;AAC1C,UAAM,OAAO,KAAK,OAAO,MAAM;AAC/B,QAAG,CAAC,QAAQ,KAAK,QAAQ,MAAK;AAC1B,cAAQ,MAAM,mBAAmB,KAAK,MAAM,kBAAkB,IAAI;AAClE,YAAM,IAAI,MAAM,oBAAqB,MAAM,MAAM,KAAK,UAAU,IAAI,IAAI,mBAAmB,IAAI;AAAA,IACnG;AACA,WAAO;AAAA,EACX;AAAA,EAEO,WAAW,QAAwB;AACtC,SAAK,SAAS,SAAS,MAAM;AAC7B,UAAM,UAAmB;AAAA,MACrB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,IACX;AAGA,WAAM,KAAK,QAAQ,GAAE;AACjB,cAAQ,KAAK,KAAK,KAAK,WAAW,CAAC;AAAA,IACvC;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,aAAkB;AAEtB,YAAO,KAAK,IAAI,EAAE,MAAK;AAAA,MACnB;AAAA,MACA;AACI,eAAO,KAAK,sBAAsB;AAAA,MACtC;AACI,eAAO,KAAK,qBAAqB;AAAA,MACrC;AACI,eAAO,KAAK,cAAc;AAAA,MAC9B;AACI,eAAO,KAAK,eAAe;AAAA,MAC/B;AACI,eAAO,KAAK,cAAc;AAAA,MAC9B;AACI,eAAO,KAAK,WAAW;AAAA,IAC/B;AAAA,EACJ;AAAA,EAEQ,iBAAuB;AAC3B,SAAK,MAAM;AAEX,UAAM,OAAO,KAAK,6BAA+B,+CAA+C,EAAE;AAElG,SAAK,4BAA8B,uDAAuD;AAC1F,UAAM,QAAQ,KAAK,oBAAoB;AACvC,SAAK,6BAA+B,sDAAsD;AAE1F,SAAK,4BAA8B,iDAAiD;AACpF,UAAM,OAAe,CAAC;AAEtB,WAAM,KAAK,IAAI,EAAE,yBAA0B,KAAK,IAAI,EAAE,6BAA8B;AAChF,WAAK,KAAK,KAAK,WAAW,CAAC;AAAA,IAC/B;AACA,SAAK,6BAA+B,iDAAiD;AACrF,WAAO,EAAC,MAAM,kBAAkB,MAAM,OAAO,KAAI;AAAA,EACrD;AAAA,EAEQ,uBAA6B;AACjC,SAAK,MAAM;AACX,UAAM,OAAO,KAAK,6BAA+B,8CAA8C,EAAE;AAEjG,UAAM,OAAO,KAAK,WAAW;AAC7B,UAAM,SAAmB,CAAC;AAC1B,eAAU,OAAO,MAAK;AAClB,UAAG,IAAI,SAAS,cAAa;AACzB,cAAM,IAAI,MAAM,uEAAuE;AAAA,MAC3F;AAEA,aAAO,KAAM,IAAmB,MAAM;AAAA,IAC1C;AAEA,SAAK,4BAA8B,+CAA+C;AAClF,UAAM,OAAe,CAAC;AAEtB,WAAM,KAAK,IAAI,EAAE,yBAA0B,KAAK,IAAI,EAAE,6BAA8B;AAChF,WAAK,KAAK,KAAK,WAAW,CAAC;AAAA,IAC/B;AACA,SAAK,6BAA+B,qDAAqD;AACzF,UAAM,KAAK;AAAA,MACP;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,MAAM;AAAA,IACV;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,wBAA6B;AACjC,UAAM,aAAa,KAAK,MAAM,EAAE;AAChC,UAAM,aAAa,KAAK,6BAA+B,0DAA0D,EAAE;AASnH,SAAK,0BAA2B,gEAAgE;AAChG,UAAM,cAAc,EAAC,MAAM,kBAAkB,YAAY,OAAO,KAAK,WAAW,GAAG,UAAU,WAAU;AAGvG,WAAO;AAAA,EACX;AAAA,EAEQ,gBAAqB;AACzB,SAAK,MAAM;AACX,SAAK,4BAA8B,+CAA+C;AAElF,UAAM,YAAY,KAAK,qBAAqB;AAI5C,SAAK,6BAA+B,8CAA8C;AAElF,SAAK,4BAA8B,4DAA4D;AAC/F,UAAM,OAAc,CAAC;AAErB,WAAM,KAAK,IAAI,EAAE,yBAA0B,KAAK,IAAI,EAAE,6BAA8B;AAChF,WAAK,KAAK,KAAK,WAAW,CAAC;AAAA,IAC/B;AACA,SAAK,6BAA+B,yDAAyD;AAE7F,QAAG,KAAK,IAAI,EAAE,yBAA0B,KAAK,KAAK,EAAE,qBAAqB;AACrE,WAAK,MAAM;AAEX,YAAM,oBAAoB,KAAK,cAAc;AAE7C,aAAO,EAAC,MAAM,iBAAiB,WAAW,MAAM,kBAAiB;AAAA,IACrE,WACQ,KAAK,IAAI,EAAE,uBAAuB;AACtC,WAAK,MAAM;AACX,UAAI,WAAkB,CAAC;AACvB,WAAK,4BAA8B,4DAA4D;AAC/F,aAAM,KAAK,IAAI,EAAE,yBAA0B,KAAK,IAAI,EAAE,6BAA8B;AAChF,iBAAS,KAAK,KAAK,WAAW,CAAC;AAAA,MACnC;AACA,WAAK,6BAA+B,yDAAyD;AAE7F,aAAO,EAAC,MAAM,iBAAiB,WAAW,MAAM,SAAQ;AAAA,IAE5D;AACK,cAAQ,IAAI,2BAA2B;AAE5C,WAAO,EAAC,MAAM,iBAAiB,WAAW,KAAI;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,aAAkB;AACtB,WAAO,KAAK,sBAAsB;AAAA,EACtC;AAAA,EAEQ,wBAA8B;AAClC,UAAM,OAAO,KAAK,kBAAkB;AAEpC,QAAG,KAAK,IAAI,EAAE,yBAAyB;AACnC,WAAK,MAAM;AACX,YAAM,QAAQ,KAAK,sBAAsB;AACzC,aAAO,EAAC,OAAO,SAAS,MAAM,MAAM,iBAAgB;AAAA,IACxD;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,oBAA0B;AAC9B,QAAG,KAAK,IAAI,EAAE,4BAA6B;AACvC,aAAO,KAAK,oBAAoB;AAAA,IACpC;AAEA,SAAK,MAAM;AACX,UAAM,aAAa,IAAI,MAAgB;AAEvC,WAAM,KAAK,QAAQ,KAAK,KAAK,IAAI,EAAE,4BAA6B;AAC5D,YAAM,MAAM,KAAK,6BAA+B,6BAA6B,EAAE;AAG/E,UAAG,KAAK,IAAI,EAAE,wBAAwB;AAClC,aAAK,MAAM;AACX,mBAAW,KAAK,EAAC,KAAK,MAAM,WAAU,CAAa;AACnD;AAAA,MACJ,WACQ,KAAK,IAAI,EAAE,4BAA6B;AAC5C,mBAAW,KAAK,EAAC,KAAK,MAAM,WAAU,CAAC;AACvC;AAAA,MACJ;AAEA,WAAK,yBAA0B,sDAAsD;AACrF,YAAM,QAAQ,KAAK,WAAW;AAE9B,iBAAW,KAAK,EAAC,MAAM,YAAY,OAAO,IAAG,CAAC;AAC9C,UAAG,KAAK,IAAI,EAAE,4BAA6B;AACvC,aAAK,yBAA0B,oDAAoD;AAAA,MACvF;AAAA,IACJ;AAEA,SAAK,6BAA+B,uCAAuC;AAC3E,WAAO,EAAC,MAAM,iBAAiB,WAAU;AAAA,EAC7C;AAAA,EAEQ,uBAA4B;AAChC,QAAI,OAAO,KAAK,oBAAoB;AACpC,UAAM,aAAa,KAAK,IAAI;AAC5B,WACI,WAAW,sCACX,WAAW,wCACX,WAAW,qCACX,WAAW,wCACX,WAAW,sCACX,WAAW,mCACX,WAAW,yCACX,WAAW,oCACd;AACG,UAAG,KAAK,IAAI,EAAE;AAA8B,eAAO;AACnD,YAAM,WAAW,KAAK,MAAM;AAC5B,UAAI;AACJ,UAAG,SAAS,wCAAyC,SAAS,oCAAoC;AAC9F,gBAAQ,KAAK,qBAAqB;AAAA,MACtC;AACK,gBAAQ,KAAK,oBAAoB;AACtC,aAAO;AAAA,QACH,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,sBAA2B;AAC/B,QAAI,OAAO,KAAK,0BAA0B;AAE1C,WAAM,KAAK,IAAI,EAAE,SAAS,OAAO,KAAK,IAAI,EAAE,SAAS,KAAI;AACrD,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,QAAQ,KAAK,0BAA0B;AAC7C,aAAO;AAAA,QACH,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,4BAAiC;AACrC,QAAI,OAAO,KAAK,uBAAuB;AAEvC,WAAM,KAAK,IAAI,EAAE,SAAS,OAAO,KAAK,IAAI,EAAE,SAAS,OAAO,KAAK,IAAI,EAAE,SAAS,KAAI;AAChF,YAAM,WAAW,KAAK,MAAM;AAC5B,YAAM,QAAQ,KAAK,uBAAuB;AAC1C,aAAO;AAAA,QACH,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,yBAA8B;AAClC,UAAM,SAAS,KAAK,kBAAkB;AAEtC,QAAG,KAAK,IAAI,EAAE,2BAA4B;AACtC,aAAO,KAAK,gBAAgB,MAAM;AAAA,IACtC,OACI;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEQ,gBAAgB,QAAmB;AACvC,QAAI,YAAkB;AAAA,MAClB,MAAM;AAAA,MACN;AAAA,MACA,MAAM,KAAK,WAAW;AAAA,IAC1B;AAEA,QAAG,KAAK,IAAI,EAAE,2BAA4B;AACtC,kBAAY,KAAK,gBAAgB,SAAS;AAAA,IAC9C;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,aAAoB;AACxB,SAAK,4BAA8B,4BAA4B;AAC/D,UAAM,OAAO,KAAK,IAAI,EAAE,6BAA+B,CAAC,IAAI,KAAK,0BAA0B;AAC3F,SAAK,6BAA+B,oDAAoD;AACxF,WAAO;AAAA,EACX;AAAA,EAEQ,4BAAmC;AACvC,UAAM,OAAO,CAAC,KAAK,sBAAsB,CAAC;AAE1C,WAAM,KAAK,IAAI,EAAE,0BAA2B,KAAK,MAAM,GAAE;AACrD,WAAK,KAAK,KAAK,sBAAsB,CAAC;AAAA,IAC1C;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,oBAAyB;AAC7B,QAAI,SAAS,KAAK,iBAAiB;AAEnC,WAAM,KAAK,IAAI,EAAE,wBAAyB,KAAK,IAAI,EAAE,6BAA8B;AAC/E,YAAM,WAAW,KAAK,MAAM;AAC5B,UAAI;AACJ,UAAI;AAGJ,UAAG,SAAS,sBAAsB;AAC9B,mBAAW;AACX,mBAAW,KAAK,mBAAmB;AAEnC,YAAG,SAAS,QAAQ,cAAa;AAC7B,gBAAM,IAAI,MAAM,sEAAsE;AAAA,QAC1F;AAAA,MACJ,OACI;AACA,mBAAW;AACX,mBAAW,KAAK,WAAW;AAC3B,aAAK,+BAAiC,4CAA4C;AAAA,MACtF;AAEA,eAAS,EAAC,MAAM,cAAc,QAAQ,UAAU,SAAQ;AAAA,IAC5D;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,mBAAwB;AAC5B,QAAG,KAAK,IAAI,EAAE,kCAAkC;AAC5C,WAAK,MAAM;AACX,YAAM,OAAO,KAAK,oBAAoB;AACtC,YAAM,QAAQ,KAAK,oBAAoB;AACvC,aAAO,EAAC,MAAM,cAAc,MAAM,OAAO,UAAU,EAAC,oCAAqC,OAAO,IAAG,EAAU;AAAA,IACjH;AACK,aAAO,KAAK,mBAAmB;AAAA,EACxC;AAAA,EAEQ,qBAA0B;AAC9B,UAAM,KAAK,KAAK,IAAI,EAAE;AAEtB,YAAO,IAAG;AAAA,MACN;AACI,eAAO,EAAC,MAAM,cAAc,QAAQ,KAAK,MAAM,EAAE,MAAM;AAAA,MAC3D;AACI,eAAO,EAAC,MAAM,kBAAkB,OAAO,WAAW,KAAK,MAAM,EAAE,KAAK,EAAE;AAAA,MAC1E;AACI,eAAO,EAAC,MAAM,iBAAiB,OAAO,KAAK,MAAM,EAAE,MAAM;AAAA,MAC7D;AACI,aAAK,MAAM;AACX,cAAM,QAAQ,KAAK,WAAW;AAC9B,aAAK,6BAA+B,oFAAoF;AACxH,eAAO;AAAA,MACX;AACI,gBAAQ,MAAM,qBAAqB,KAAK,IAAI,GAAG,uBAAuB;AACtE,cAAM,IAAI,MAAM,sBAAsB,KAAK,UAAU,KAAK,IAAI,CAAC,IAAI,uBAAuB;AAAA,IAClG;AAAA,EACJ;AACJ;;;AChYO,SAAS,cAAa;AACzB,SAAO,EAAC,MAAM,QAAQ,OAAO,KAAI;AACrC;AAOO,SAAS,YAAY,QAAQ,MAAK;AACrC,SAAO,EAAC,MAAM,WAAW,MAAK;AAClC;AAOO,SAAS,cAAc,QAAQ,GAAE;AACpC,SAAO,EAAC,MAAM,UAAU,MAAK;AACjC;AAOO,SAAS,cAAc,QAAQ,IAAG;AACrC,SAAO,EAAC,MAAM,UAAU,MAAK;AACjC;AAcO,SAAS,gBAAgB,MAAmB;AAC/C,SAAO,EAAE,MAAM,YAAY,KAAI;AACnC;;;ACvDA,IAAqB,UAArB,MAA4B;AAAA,EACjB,IAAI,MAAsB,OAAkC;AAC/D,QAAI,WAAkB;AACtB,eAAU,OAAO,MAAK;AAClB,UAAG,IAAI,QAAQ,UAAS;AACpB,oBAAa,IAAoB;AAAA,MACrC,WACQ,IAAI,QAAQ,UAAS;AACzB,oBAAa,IAAoB,MAAM,SAAS;AAAA,MACpD,WACQ,IAAI,QAAQ,WAAU;AAC1B,oBAAa,IAAqB,MAAM,SAAS;AAAA,MACrD,OACK;AACD,gBAAQ,IAAI,QAAQ;AACpB,gBAAQ,IAAI,GAAG;AACf,eAAO,YAAY;AAAA,MACvB;AACA,kBAAY;AAAA,IAChB;AACA,YAAQ,IAAI,QAAQ;AACpB,WAAO,YAAY;AAAA,EACvB;AAAA,EACO,MAAM,MAAsB,OAAkC;AACjE,QAAI,SAAuB,YAAY;AACvC,QAAG,KAAK,CAAC,EAAE,QAAQ,UAAS;AACxB,eAAS,cAAe,KAAK,CAAC,EAAkB,MAAM,YAAY,CAAC;AAAA,IACvE,OACI;AACA,YAAM,IAAI,MAAM,gBAAgB,KAAK,CAAC,EAAE,OAAO,6CAA6C;AAAA,IAChG;AACA,WAAO;AAAA,EACX;AAAA,EACO,MAAM,MAAsB,OAAkC;AACjE,QAAI,SAAuB,YAAY;AACvC,QAAG,KAAK,CAAC,EAAE,QAAQ,UAAS;AACxB,eAAS,cAAe,KAAK,CAAC,EAAkB,MAAM,YAAY,CAAC;AAAA,IACvE,OACI;AACA,YAAM,IAAI,MAAM,gBAAgB,KAAK,CAAC,EAAE,OAAO,6CAA6C;AAAA,IAChG;AACA,WAAO;AAAA,EACX;AACJ;;;AC5CO,SAAS,0BAAyB;AACrC,QAAM,UAAU,IAAI,QAAQ;AAC5B,QAAM,MAAM,IAAI,YAAY;AAG5B,MAAI,WAAW,QAAQ,YAAY,IAAI,GAAG,IAAI;AAC9C,MAAI,WAAW,SAAS,YAAY,KAAK,GAAG,IAAI;AAChD,MAAI,WAAW,QAAQ,YAAY,GAAG,IAAI;AAG1C,MAAI,WAAW,OAAO,gBAAgB,QAAQ,GAAG,GAAG,IAAI;AACxD,MAAI,WAAW,SAAS,gBAAgB,QAAQ,KAAK,GAAG,IAAI;AAC5D,MAAI,WAAW,SAAS,gBAAgB,QAAQ,KAAK,GAAG,IAAI;AAC5D,MAAI,WAAW,QAAQ,cAAc,KAAK,IAAI,CAAC,GAAG,IAAI;AAEtD,SAAO;AACX;AAEA,IAAqB,cAArB,MAAgC;AAAA,EAK5B,YAAY,WAAwB;AAChC,SAAK,SAAS;AACd,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,YAAY,oBAAI,IAAI;AAAA,EAC7B;AAAA,EAEO,WAAW,SAAiB,OAAqB,UAAgC;AACpF,QAAG,KAAK,UAAU,IAAI,OAAO,GAAE;AAC3B,YAAM,IAAI,MAAM,6BAA6B,UAAU,6BAA6B;AAAA,IACxF;AAEA,SAAK,UAAU,IAAI,SAAS,KAAK;AAEjC,QAAG;AAAU,WAAK,UAAU,IAAI,OAAO;AACvC,WAAO;AAAA,EACX;AAAA,EAEO,UAAU,SAAiB,OAAkC;AAChE,UAAM,MAAM,KAAK,QAAQ,OAAO;AAEhC,QAAG,IAAI,UAAU,IAAI,OAAO,GAAE;AAC1B,YAAM,IAAI,MAAM,iCAAiC,UAAU,kCAAkC;AAAA,IACjG;AAEA,QAAI,UAAU,IAAI,SAAS,KAAK;AAChC,WAAO;AAAA,EACX;AAAA,EAEO,UAAU,SAA8B;AAC3C,UAAM,MAAM,KAAK,QAAQ,OAAO;AAChC,WAAO,IAAI,UAAU,IAAI,OAAO;AAAA,EACpC;AAAA,EAEO,QAAQ,SAA6B;AACxC,QAAG,KAAK,UAAU,IAAI,OAAO;AAAG,aAAO;AACvC,QAAG,KAAK,UAAU;AAAW,YAAM,IAAI,MAAM,oBAAoB,UAAU,wBAAwB;AACnG,WAAO,KAAK,OAAO,QAAQ,OAAO;AAAA,EACtC;AACJ;;;ACxDO,SAAS,sBAAsB,OAAmB,KAA+B;AACpF,QAAM,MAAM,UAAU,MAAM,MAAM,GAAG;AACrC,QAAM,MAAM,UAAU,MAAM,OAAO,GAAG;AAEtC,MAAG,MAAM,SAAS,sCAAuC,MAAM,SAAS,wCAAyC,MAAM,SAAS,qCAAsC,MAAM,SAAS,wCAAyC,MAAM,SAAS,mCAAoC,MAAM,SAAS,sCAAuC,MAAM,SAAS,sCAAuC,MAAM,SAAS,uCAAuC;AAC/a,WAAO,gCAAgC,KAAK,KAAK,MAAM,QAAQ;AAAA,EACnE;AACA,MAAG,IAAI,QAAQ,YAAY,IAAI,QAAQ,UAAS;AAC5C,WAAO,8BAA8B,KAAoB,KAAoB,MAAM,QAAQ;AAAA,EAC/F;AACA,MAAG,IAAI,QAAQ,YAAY,IAAI,QAAQ,YAAY,MAAM,SAAS,SAAS,KAAI;AAC3E,WAAO,6BAA6B,KAAoB,GAAkB;AAAA,EAC9E;AAEA,SAAO,YAAY;AACvB;AAEO,SAAS,gCAAgC,KAAmB,KAAmB,UAA8B;AAChH,MAAG,SAAS,mCAAmC;AAC3C,QAAG,OAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,sCAAsC;AACnD,QAAG,OAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,oCAAoC;AACjD,QAAG,MAAM,KAAI;AACT,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,iCAAiC;AAC9C,QAAG,MAAM,KAAI;AACT,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,oCAAoC;AACjD,QAAG,MAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,uCAAuC;AACpD,QAAG,MAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,oCAAoC;AACjD,QAAG,OAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C,WACQ,SAAS,sCAAsC;AACnD,QAAG,OAAO,KAAI;AACV,aAAO,EAAC,MAAM,WAAW,OAAO,KAAI;AAAA,IACxC;AACK,aAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAAA,EAC9C;AACK,WAAO,EAAC,MAAM,WAAW,OAAO,MAAK;AAC9C;AAEO,SAAS,6BAA6B,KAAkB,KAA8B;AACzF,QAAM,SAAS,IAAI,QAAQ,IAAI;AAC/B,SAAO,EAAE,MAAM,UAAU,OAAO,OAAM;AAC1C;AAEO,SAAS,8BAA8B,KAAkB,KAAkB,UAA6B;AAC3G,MAAI,SAAS;AACb,MAAG,SAAS,SAAS;AAAK,aAAS,IAAI,QAAQ,IAAI;AAAA,WAC3C,SAAS,SAAS;AAAK,aAAS,IAAI,QAAQ,IAAI;AAAA,WAChD,SAAS,SAAS;AAAK,aAAS,IAAI,QAAQ,IAAI;AAAA,WAChD,SAAS,SAAS;AAAK,aAAS,IAAI,QAAQ,IAAI;AAAA,WAChD,SAAS,SAAS;AAAK,aAAS,IAAI,QAAQ,IAAI;AAAA;AACnD,UAAM,IAAI,MAAM,kBAAkB,SAAS,QAAQ,kEAAkE;AAC1H,SAAO,EAAE,MAAM,UAAU,OAAO,OAAM;AAC1C;AAEO,SAAS,qBAAqB,YAAwB,KAA+B;AACxF,QAAM,QAAQ,IAAI,UAAU,WAAW,MAAM;AAC7C,SAAO;AACX;AAEO,SAAS,sBAAsB,KAAoB,KAA+B;AACrF,QAAM,SAAS,EAAE,MAAM,UAAU,YAAY,oBAAI,IAAI,EAAC;AAEtD,aAAU,EAAC,KAAK,MAAK,KAAK,IAAI,YAAW;AAErC,UAAM,eAAgB,SAAS,SAAa,IAAI,UAAU,GAAG,IAAI,UAAU,OAAO,GAAG;AAErF,WAAO,WAAW,IAAI,KAAK,YAAY;AAAA,EAC3C;AAEA,SAAO;AACX;AAEO,SAAS,sBAAsB,MAAkB,KAA+B;AACnF,QAAM,MAAM,UAAU,KAAK,QAAQ,GAAG;AACtC,MAAG,IAAI,QAAQ,UAAS;AACpB,UAAM,MAAM;AACZ,QAAI;AACJ,QAAG,KAAK,UAAS;AACb,UAAI;AACJ,UAAG,KAAK,SAAS,QAAQ;AAAiB,gBAAQ,IAAI,WAAW,IAAK,KAAK,SAA2B,KAAK;AAAA,WACvG;AACA,wBAAgB,UAAU,KAAK,UAAU,GAAG;AAC5C,YAAG,CAAC,eAAc;AACd,kBAAQ,MAAM,wCAAwC,KAAK,QAAQ;AACnE,gBAAM,IAAI,MAAM,yCAAyC,KAAK,UAAU,KAAK,QAAQ,CAAC;AAAA,QAC1F;AACA,gBAAQ,IAAI,WAAW,IAAK,cAAgC,KAAK;AAAA,MACrE;AAAA,IACJ,OACI;AACA,UAAG,KAAK,SAAS,QAAQ;AAAc,gBAAQ,IAAI,WAAW,IAAK,KAAK,SAAwB,MAAM;AAAA,IAC1G;AACA,QAAG,CAAC;AAAO,cAAQ,YAAY;AAC/B,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEO,SAAS,oBAAoB,MAAgB,KAA+B;AAC/E,QAAM,OAAO,KAAK,KAAK,IAAI,CAAC,QAAQ,UAAU,KAAK,GAAG,CAAC;AACvD,QAAM,KAAK,UAAU,KAAK,QAAQ,GAAG;AAErC,MAAG,GAAG,QAAQ,YAAW;AACrB,UAAM,SAAU,GAAqB,KAAK,MAAM,GAAG;AACnD,WAAO;AAAA,EACX;AAEA,MAAG,GAAG,QAAQ,YAAW;AACrB,UAAM,OAAO;AACb,UAAM,QAAQ,IAAI,YAAY,KAAK,cAAc;AAEjD,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,KAAK;AAC7C,UAAG,KAAK,WAAW,SAAS,KAAK,QAAO;AACpC,cAAM,IAAI,MAAM,4EAA4E,KAAK,WAAW,SAAS,wBAAwB,KAAK,MAAM;AAAA,MAC5J,WACQ,KAAK,WAAW,SAAS,KAAK,QACtC;AACI,cAAM,IAAI,MAAM,+EAA+E,KAAK,WAAW,MAAM;AAAA,MACzH;AACA,YAAM,UAAU,KAAK,WAAW,CAAC;AACjC,YAAM,WAAW,SAAS,KAAK,CAAC,GAAG,KAAK;AAAA,IAC5C;AAEA,QAAI,SAAuB,YAAY;AAEvC,eAAU,QAAQ,KAAK,MAAK;AACxB,eAAS,UAAU,MAAM,KAAK;AAAA,IAClC;AACA,WAAO;AAAA,EACX;AAEA,UAAQ,MAAM,8CAA8C,EAAE;AAC9D,QAAM,IAAI,MAAM,+CAA+C,KAAK,UAAU,EAAE,CAAC;AACrF;AAEO,SAAS,qBAAqB,MAAsB,KAA+B;AACtF,MAAG,KAAK,QAAQ,SAAS,cAAa;AAClC,YAAQ,MAAM,+CAA+C,KAAK,OAAO;AACzE,UAAM,IAAI,MAAM,gDAAgD,KAAK,UAAU,KAAK,OAAO,CAAC;AAAA,EAChG;AAEA,QAAM,UAAW,KAAK,QAAuB;AAC7C,SAAO,IAAI,UAAU,SAAS,UAAU,KAAK,OAAO,GAAG,CAAC;AAC5D;;;AC/KO,SAAS,kBAAkB,SAAkB,KAA+B;AAC/E,MAAI,kBAAgC,YAAY;AAEhD,aAAU,aAAa,QAAQ,MAAK;AAChC,sBAAkB,UAAU,WAAW,GAAG;AAAA,EAC9C;AACA,SAAO;AACX;AAEO,SAAS,0BAA0B,aAA6B,KAA+B;AAClG,QAAM,QAAQ,YAAY,QAAQ,UAAU,YAAY,OAAO,GAAG,IAAI,YAAY;AAClF,SAAO,IAAI,WAAW,YAAY,YAAY,OAAO,YAAY,QAAQ;AAC7E;AAEO,SAAS,yBAAyB,aAAkC,KAA+B;AACtG,QAAM,KAAK;AAAA,IACP,MAAM;AAAA,IACN,MAAM,YAAY;AAAA,IAClB,YAAY,YAAY;AAAA,IACxB,gBAAgB;AAAA,IAChB,MAAM,YAAY;AAAA,EACtB;AAEA,SAAO,IAAI,WAAW,YAAY,MAAM,IAAI,IAAI;AACpD;AAEO,SAAS,yBAAyB,aAA4B,KAA+B;AAEhG,QAAM,QAAQ,UAAU,YAAY,WAAW,GAAG;AAClD,MAAI,MAAuB,SAAS,MAAK;AACrC,QAAI,SAAuB,YAAY;AAEvC,eAAU,QAAQ,YAAY,MAAK;AAC/B,eAAS,UAAU,MAAM,GAAG;AAAA,IAChC;AACA,WAAO;AAAA,EACX,WACQ,YAAY,mBAAkB;AAClC,UAAM,YAAY,yBAAyB,YAAY,mBAAmB,GAAG;AAC7E,WAAO;AAAA,EACX,WACQ,YAAY,UAAS;AACzB,QAAI,SAAuB,YAAY;AAEvC,eAAU,QAAQ,YAAY,UAAS;AACnC,eAAS,UAAU,MAAM,GAAG;AAAA,IAChC;AACA,WAAO;AAAA,EACX,OACI;AACA,WAAO,YAAY;AAAA,EACvB;AACJ;AAEO,SAAS,0BAA0B,aAA6B,KAA+B;AAClG,MAAG,YAAY,MAAM,QAAQ,kBAAiB;AAC1C,QAAI;AACJ,aAAQ,IAAI,GAAG,IAAK,YAAY,MAAyB,OAAO,KAAI;AAChE,iBAAU,QAAQ,YAAY,MAAK;AAC/B,iBAAS,UAAU,MAAM,GAAG;AAAA,MAChC;AAAA,IACJ;AACA,WAAO;AAAA,EACX,OACI;AACA,YAAQ,IAAI,0EAA0E,YAAY,KAAK;AACvG,WAAO,YAAY;AAAA,EACvB;AACJ;;;ACrEO,SAAS,UAAU,SAAe,KAAgC;AAErE,UAAO,QAAQ,MAAK;AAAA,IAChB,KAAK;AACD,aAAO,EAAC,OAAS,QAA2B,OAAQ,MAAM,SAAQ;AAAA,IACtE,KAAK;AACD,aAAO,EAAC,OAAS,QAA0B,OAAQ,MAAM,SAAQ;AAAA,IACrE,KAAK;AACD,aAAO,qBAAqB,SAAuB,GAAG;AAAA,IAC1D,KAAK;AACD,aAAO,sBAAsB,SAA0B,GAAG;AAAA,IAC9D,KAAK;AACD,aAAO,oBAAoB,SAAqB,GAAG;AAAA,IACvD,KAAK;AACD,aAAO,sBAAsB,SAAuB,GAAG;AAAA,IAC3D,KAAK;AACD,aAAO,sBAAsB,SAAuB,GAAG;AAAA,IAC3D,KAAK;AACD,aAAO,qBAAqB,SAA2B,GAAG;AAAA,IAC9D,KAAK;AACD,aAAO,kBAAkB,SAAoB,GAAG;AAAA,IACpD,KAAK;AACD,aAAO,0BAA0B,SAA2B,GAAG;AAAA,IACnE,KAAK;AACD,aAAO,yBAAyB,SAAgC,GAAG;AAAA,IACvE,KAAK;AACD,aAAO,yBAAyB,SAA0B,GAAG;AAAA,IACjE,KAAK;AACD,aAAO,0BAA0B,SAA2B,GAAG;AAAA,IACnE;AACI,cAAQ,MAAM,6DAA6D,OAAO;AAClF,YAAM,IAAI,MAAM,8DAA8D,KAAK,UAAU,OAAO,CAAC;AAAA,EAC7G;AACJ;;;ACpCA,SAAoB;AAMpB,SAAsB,YAAY,aAAqB;AAAA;AACnD,UAAM,MAAM,wBAAwB;AAEpC,YAAQ,IAAI,mBAAmB;AAE/B,UAAM,QAAW,gBAAa,WAAW,EAAE,SAAS;AAEpD,UAAM,SAAS,IAAI,OAAO;AAC1B,UAAM,UAAU,OAAO,WAAW,KAAK;AAGvC,UAAM,SAAS,UAAU,SAAS,GAAG;AAAA,EAEzC;AAAA;;;AThBO,SAAS,IAAI,OAAa;AAC7B,cAAY,KAAK;AACrB;","names":[]}